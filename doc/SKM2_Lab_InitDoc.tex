
\documentclass[a4paper,12pt]{article}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{relsize}
\usepackage{indentfirst}
\usepackage[MeX]{polski}
\usepackage[latin2]{inputenc}
\usepackage[polish]{babel}

\title{
    \textbf{Sieci komputerowe 2 \\ Laboratorium} \\
    {\normalsize<<Æwiczenie 1/5: Implementacja protoko³u warstwy 2 na wspólnej szynie>>} \\
    {\large{>>Dokumentacja wstêpna<<}}
}

\author{
    \makebox[8em][c]{Piotr Ba³ut} \and
    \makebox[8em][c]{Maciej Rubikowski} \and
    \makebox[8em][c]{Tomasz Pieczerak}
}

\addtolength{\oddsidemargin}{-.3in}
\addtolength{\evensidemargin}{-.3in}
\addtolength{\textwidth}{0.6in}
\addtolength{\topmargin}{-.75in}
\addtolength{\textheight}{1.5in}

\begin{document}
\maketitle

\section{Tre¶æ zadania}
Zaimplementowaæ sieæ typu master-slave wykorzystuj±c jako warstwê fizyczn±
³±cze RS485. Powinny byæ dostêpne nastêpuj±ce us³ugi warstwy ³±cza danych:

\begin{itemize}
    \item Send Data with Acknowledge (SDA);
    \item Send Data with No Acknowledge (SDN) -- us³uga typu broadcast.
\end{itemize}

\paragraph{Za³o¿enia}\

\begin{itemize}
    \item ka¿dy wêze³ sieci posiada unikalny identyfikator (liczba 8-bitowa),
    \item maksymalna liczba wêz³ów w sieci wynosi $64$,
    \item w sieci znajduje siê jeden wêze³ (\emph{master}) zarz±dzaj±cy
          dostêpem do ³±cza oraz wiele wêz³ów podrzêdnych (\emph{slave}),
    \item wêze³ zarz±dzaj±cy (\emph{master}) zna adresy wszystkich wêz³ów
          pod³±czonych do sieci (ale niektóre z nich mog± byæ wy³±czone).
\end{itemize}

Szczególn± uwagê nale¿y zwróciæ na obs³ugê b³êdów (nale¿y wprowadziæ
mechanizmy symulowania b³êdów). Implementacja ma zostaæ wykonana w ¶rodowisku
GNU/Linux.

\section{Dodatkowe za³o¿enia}

W trakcie analizy tre¶ci zadania dostrzegli¶my potrzebê wprowadzenia pewnych
dodatkowych za³o¿eñ/ograniczeñ precyzuj±cych implementowane zagadnienie:

\begin{itemize}
    \item rozwi±zanie \textbf{nie musi} byæ optymalne -- naszym celem nie jest
          stworzenie najbardziej wydajnej sieci, lecz sieci \emph{po prostu
          dzia³aj±cej};
    \item nie implementujemy procesu rejestracji maszyn, tj. ka¿dy host typu
          \emph{slave} posiada przypisany na sta³e adres, o którym wiedzê
          posiada \emph{master};
    \item dostarczone funkcje obs³uguj±ce wysy³anie/odbieranie danych na/z
          szyny opieraj± siê na komunikacji znakowej, tote¿ nie ma sensu ¿mudne
          budowanie nag³ówków ramek z pojedynczych bitów; operowaæ bêdziemy
          \emph{zawsze} na bajtach;
    \item jako ¿e pracujemy w warstwie sieciowej nie musimy dbaæ o poprawn±
          interpretacjê danych zawartych w pakietach, naszym zadaniem jest
          tylko i wy³±cznie zapewnienie poprawnego przesy³u pakietów, sk³adanie
          tych¿e w sensowne komunikaty le¿y w gestii oprogramowania warstw
          wy¿szych;
    \item konieczna jest weryfikacja poprawno¶ci przesy³anych danych,
          w szczególno¶ci nale¿y dodaæ do nag³ówka sumê kontroln± pakietu
          (\emph{CRC});
    \item \emph{master} jest wy³±cznie wêz³em kontroluj±cym szynê -- nie
          odbiera ani nie wysy³a ¿adnych pakietów danych.
\end{itemize}

\section{Algorytmy do zaimplementowania}

\paragraph{Przydzia³ ³±cza}\

Koncepcja algorytmu przydzia³u ³±cza przez maszynê \emph{master} opiera siê na
znanym z zagadnienia szeregowania procesów algorytmie \emph{Round Robin}.
\emph{Master} odpytuje kolejno wszystkie maszyny, wysy³aj±c pakiety
\texttt{BUS} i czekaj±c na odpowied¼ (przy czym mo¿liwy jest timeout
w sytuacji, gdy host jest wy³±czony). Gdy jedna z maszyn zg³asza chêæ wys³ania
pakietu danych, master wysy³a do tej maszyny pakiet \texttt{RDY} (tj. wystawia
go na szynê z odpowiednim adresem), a nastêpnie przydziela jej potrzebne okno
czasowe, wynosz±ce co najmniej: $t_{transmisji\ pakietu} + t_{transmisji\
odpowiedzi}$. Po up³yniêciu tego czasu \emph{master} wznawia odpytywanie
wêz³ów od nastêpnika wêz³a, który w³a¶nie przes³a³ pakiet (tj. je¶li w tablicy
hostów \emph{mastera} host ¿±daj±cy dostêpu mia³ indeks $k$, to odpytywanie
jest wznawiane od hosta $k+1$). 

\paragraph{Przesy³ danych}\

\emph{Slave}, który chce przes³aæ dane, musi oczekiwaæ na pakiety \texttt{BUS}
pochodz±ce od \emph{mastera} i w momencie otrzymania pakietu \textbf{ze swoim
adresem} poprawnie nañ odpowiedzieæ, wysy³aj±c na szynê pakiet \texttt{REQ} --
warto zwróciæ uwagê, ¿e pakiet ten nie musi posiadaæ adresu wêz³a ¿±daj±cego
dostêpu, bowiem \emph{master} wie, którego \emph{slave'a} w³a¶nie odpytuje.
Po przydzieleniu ³±cza host wysy³aj±cy wystawia na szynê pakiet, który chcia³
wys³aæ, po czym czeka na potwierdzenie (\texttt{ACK}) od hosta odbieraj±cego.
W przypadku braku potwierdzenia w nastêpnym cyklu szyny (a w³a¶ciwie
\emph{mastera}) bêdzie musia³ dokonaæ retransmisji. Takie podej¶cie rozwi±zuje
od razu dwa problemy: problem b³êdnego przesy³u oraz wy³±czenie hosta
docelowego (wtedy równie¿ potrzebna jest retransmisja, a host wy³±czony nie
prze¶le \texttt{ACK}). W sytuacji, gdy host wysy³aj±cy zostanie nagle
wy³±czony, sprawê rozwi±zuje timeout w wê¼le \emph{master}. 

\paragraph{Weryfikacja poprawno¶ci datagramów}\

Do weryfikacji poprawno¶ci przesy³anych przez hosty pakietów danych
(\texttt{DAT}) pos³u¿y \emph{cykliczny kod nadmiarowy} w wersji \emph{CRC16}.
Kod funkcji obliczaj±cej sumê kontroln± zosta³ dostarczony przez prowadz±cych.
Weryfikowane bêd± wy³±cznie ramki danych. Weryfikacja pakietów \texttt{BUS}
czy \texttt{REQ} dodatkowo wyd³u¿y³aby cykl szyny i tak naprawdê nie jest do
niczego potrzebna -- ewentualne b³êdy w transmisji nie s± krytyczne.
Weryfikacja broadcastu nie ma sensu, gdy¿ powtórne przes³anie danych
powodowa³oby otrzymywanie przez niektóre wêz³y zwielokrotnionych pakietów.

\section{Formaty ramek}

Projektowane rozwi±zanie wykorzystywaæ bêdzie nastêpuj±ce typy ramek: 

\begin{itemize}
    \item BUS [01h] -- zapytanie o zainteresowanie szyn± (1 bajt adresu hosta
                       pytanego);
    \item REQ [02h] -- ¿±danie dostêpu do szyny (bez dodatkowych nag³ówków --
                       master wie, kogo pyta³);
    \item RDY [03h] -- przydzia³ szyny (1 bajt adresu hosta);
    \item DAT [04h] -- pakiet danych (suma CRC, 1 bajt adresu nadawcy, 1 bajt
                       adresu odbiorcy, 1 bajt na rozmiar wiadomo¶ci w bajtach,
                       sama wiadomo¶æ);
    \item ACK [05h] -- potwierdzenie otrzymania danych (bez dodatkowych
                       parametrów - w danych momencie na szynie oczekuje siê na
                       jeden i tylko jeden pakiet \texttt{ACK});
    \item BRD [06h] -- broadcast, nie podlega weryfikacji (1 bajt na rozmiar
                       wiadomo¶ci + wiadomo¶æ).
\end{itemize}
Uwaga: pierwszy bajt nag³ówka ka¿dej ramki zawieraæ bêdzie jej typ (wed³ug
podanych w nawiasach kwadratowych kodów).

\section{Architektura rozwi±zania}

Przygotowaæ nale¿y dwa programy w jêzyku C: program dla wêz³a \emph{master}
oraz dla poszczególnych wêz³ów \emph{slave}:
\begin{itemize}
    \item \texttt{mss-bus-master} to program dzia³aj±cy na wê¼le
          \emph{master}. Utrzymuje on statyczn± tablicê adresów hostów
          \emph{slave} i kontroluje dostêp do szyny poprzez cykliczne (w
          jednym w±tku) wysy³anie pakietów \texttt{BUS} do kolejnych maszyn
          i nastêpnie oczekiwanie na odpowied¼ (\texttt{REQ}) b±d¼ (z d³u¿szym
          timeoutem) na zakoñczenie transmisji (po wys³aniu do wêz³a
          nadaj±cego pakietu \texttt{RDY}).
    \item \texttt{mss-bus-slave} to program "kliencki", który bêdzie dzia³a³
          dwóch trybach (które mog± siê przeplataæ):
          \begin{itemize}
              \item pasywnym : tu host bêdzie oczekiwa³ na dane adresowane do
                               niego, odbiera³ je i potwierdza³ odbiór,
              \item aktywnym : poza powy¿szym host bêdzie czeka³ na pakiet
                               \emph{BUS} adresowany do niego, po jego
                               odebraniu i otrzymaniu zezwolenia na transmisjê
                               rozpocznie wysy³anie danych, nastêpnie poczeka
                               jeszcze na pakiet \emph{ACK} upewniaj±c siê, ¿e
                               dane zosta³y poprawnie odebrane i wróci do
                               trybu pasywnego.
          \end{itemize}
          Tryb aktywny s³u¿y oczywi¶cie do wysy³ania danych przez szynê do
          innych hostów -- mo¿liwa jest transmisja do konkretnej stacji lub
          skorzystanie z us³ugi \emph{broadcast}.
\end{itemize}

\section{Projekt testowania}

Testy odbêd± siê w sali 138, bo tam w³a¶nie znajduje siê Wspólna
Szyna\texttrademark. Do testów czasy wszystkich timeout'ów zostan± znacznie
wyd³u¿one, tak aby mo¿liwa by³a dok³adna obserwacja zachowania siê
protoko³u.

Przetestowane zostan± przede wszystkim sytuacje awaryjne, w szczególno¶ci
od³±czanie wêz³ów w trakcie transmisji/poza transmisj±, wy³±czanie nadawców
i odbiorców, wy³±czanie i w³±czanie urz±dzeñ, zak³ócenia.

\end{document}

