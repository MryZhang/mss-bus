
\documentclass[a4paper,12pt]{article}
\usepackage{latexsym}
\usepackage{amsfonts}
\usepackage{relsize}
\usepackage{indentfirst}
\usepackage[MeX]{polski}
\usepackage[latin2]{inputenc}
\usepackage[polish]{babel}

\title{
    \textbf{Sieci komputerowe 2 \\ Laboratorium} \\
    {\normalsize<<Æwiczenie 1/5: Implementacja protoko³u warstwy 2 na wspólnej szynie>>} \\
    {\large{>>Dokumentacja wstêpna<<}}
}

\author{
    \makebox[8em][c]{Piotr Ba³ut} \and
    \makebox[8em][c]{Maciej Rubikowski} \and
    \makebox[8em][c]{Tomasz Pieczerak}
}

\addtolength{\oddsidemargin}{-.3in}
\addtolength{\evensidemargin}{-.3in}
\addtolength{\textwidth}{0.6in}
\addtolength{\topmargin}{-.75in}
\addtolength{\textheight}{1.5in}

\begin{document}
\maketitle

\section{Tre¶æ zadania}
Zaimplementowaæ sieæ typu master-slave wykorzystuj±c jako warstwê fizyczn±
³±cze RS485. Powinny byæ dostêpne nastêpuj±ce us³ugi warstwy ³±cza danych:

\begin{itemize}
  \item Send Data with Acknowledge (SDA);
  \item Send Data with No Acknowledge (SDN) -- us³uga typu broadcast.
\end{itemize}

\paragraph{Za³o¿enia}\

\begin{itemize}
  \item ka¿dy wêze³ sieci posiada unikalny identyfikator (liczba 8-bitowa),
  \item maksymalna liczba wêz³ów w sieci wynosi $64$,
  \item w sieci znajduje siê jeden wêze³ (\emph{master}) zarz±dzaj±cy
        dostêpem do ³±cza oraz wiele wêz³ów podrzêdnych (\emph{slave}),
  \item wêze³ zarz±dzaj±cy (\emph{master}) zna adresy wszystkich wêz³ów
        pod³±czonych do sieci (ale niektóre z nich mog± byæ wy³±czone).
\end{itemize}

Szczególn± uwagê nale¿y zwróciæ na obs³ugê b³êdów (nale¿y wprowadziæ
mechanizmy symulowania b³êdów). Implementacja ma zostaæ wykonana w ¶rodowisku
GNU/Linux.

\section{Dodatkowe za³o¿enia}

W trakcie analizy tre¶ci zadania dostrzegli¶my potrzebê wprowadzenia pewnych
dodatkowych za³o¿eñ/ograniczeñ precyzuj±cych implementowane zagadnienie:

\begin{itemize}
  \item rozwi±zanie \textbf{nie musi} byæ optymalne -- naszym celem nie jest
        stworzenie najbardziej wydajnej sieci, lecz sieci \emph{po prostu
        dzia³aj±cej};
  \item nie implementujemy procesu rejestracji maszyn, tj. ka¿dy host typu
        \emph{slave} posiada przypisany na sta³e adres, o którym wiedzê
        posiada \emph{master};
  \item dostarczone funkcje obs³uguj±ce wysy³anie/odbieranie danych na/z
        szyny opieraj± siê na komunikacji znakowej, tote¿ nie ma sensu ¿mudne
        budowanie nag³ówków ramek z pojedynczych bitów; operowaæ bêdziemy
        \emph{zawsze} na bajtach;
  \item jako ¿e pracujemy w warstwie sieciowej nie musimy dbaæ o poprawn±
        interpretacjê danych zawartych w pakietach, naszym zadaniem jest
        tylko i wy³±cznie zapewnienie poprawnego przesy³u pakietów, sk³adanie
        tych¿e w sensowne komunikaty le¿y w gestii oprogramowania warstw
        wy¿szych;
  \item konieczna jest weryfikacja poprawno¶ci przesy³anych danych,
        w szczególno¶ci nale¿y dodaæ do nag³ówka sumê kontroln± pakietu
        (\emph{CRC});
  \item \emph{master} jest wy³±cznie wêz³em kontroluj±cym szynê -- nie
        odbiera ani nie wysy³a ¿adnych pakietów danych.
\end{itemize}

\section{Logika protoko³u}

\paragraph{Przydzia³ ³±cza}\

Przydzia³ ³±cza przez maszynê \emph{master} opiera siê na algorytmie
\emph{Round Robin}. Wêze³ zarz±dzaj±cy odpytuje kolejno wszystkie maszyny
\emph{slave}, wysy³aj±c do nich pakiet \texttt{BUS}. Je¶li dana maszyna chce
rozpocz±æ transmisjê odpowiada pakietem \texttt{REQ} i rozpoczyna transmisjê.
W ramach pojedynczej transmisji mo¿na wys³aæ do 10 bajtów danych (w pakiecie
\texttt{DAT}), po czym w przypadku transmisji z potwierdzeniem nastêpuje
odpowied¼ odbiorcy pakietem \texttt{ACK}. Nastêpnie \emph{master} ponownie
przejmuje szynê i kontynuuje odpytywanie od nastêpnej maszyny.

\paragraph{Przesy³ danych (z punktu widzenia u¿ytkownika)}\

Maszyna \emph{slave} chc±c przes³aæ dane nas³uchuje na szynie czekaj±c na
swoj± kolejkê -- tj. czeka na pakiet \texttt{BUS} adresowany do niej. Po
otrzymaniu takowego odpowiada pakietem \texttt{REQ} i mo¿e rozpocz±æ
transmisjê, czyli wys³aæ \textbf{jeden} pakiet \texttt{DAT} o zmiennej
d³ugo¶ci pola danych od 1 do 10 bajtów. Je¶li pakiet nie by³ wys³any na adres
\emph{broadcast'owy} czeka jeszcze na otrzymanie potwierdzenia i zwalnia
szynê. W przypadku, gdy zosta³y jeszcze dane do wys³ania czeka na ponowny
przydzia³ i po jego otrzymaniu powtarza procedurê.

Obowi±zek reakcji na brak potwierdzenia le¿y po stronie aplikacji, a nie
protoko³u -- choæ oczywi¶cie aplikacja zostanie poinformowana o zaistnia³ej
sytuacji.

\paragraph{Kwestia \emph{timeout'ów}}\

Istniej± dwie sytuacje, w których konieczne jest wprowadzenie czasowego
przeterminowania odpowiedzi na pakiety, aby zapobiec zawieszeniu dzia³ania
protoko³u z powodu nieobecno¶ci której¶ ze stacji:
\begin{itemize}
  \item odpowied¼ \emph{slave'a} na pakiet \texttt{REQ},
  \item potwierdzenie \texttt{ACK} odebrania danych przez \emph{slave'a}
        (odbiorcê).
\end{itemize}
Aby upro¶ciæ tworzenie protoko³u zamiast mierzyæ rzeczywisty up³yw czasu
uznali¶my, ¿e wystarczaj±cym kryterium bêdzie pojawienie siê bajtu
oznaczaj±cego pocz±tek ramki w pewnej liczbie odebranych bajtów po rozpoczêciu
oczekiwania. W obu wymienionych powy¿ej przypadkach uznajemy, ¿e je¶li
w pierwszych 5 bajtach nie pojawi siê znacznik pocz±tku poprawnej ramki,
nas³uchuj±cy mo¿e uznaæ, i¿ odpowiedzi nie by³o.

\paragraph{Weryfikacja poprawno¶ci datagramów}\

Ka¿da wysy³ana ramka jest opatrzona \emph{cyklicznym kodem nadmiarowym}
\emph{CRC16}. Kod funkcji obliczaj±cej sumê kontroln± zosta³ dostarczony
przez prowadz±cych.

\section{Formaty ramek}

Ogólny format ramek wykorzystywanych przez protokó³ wygl±da nastêpuj±co:
\begin{displaymath}
  \underbrace{\hbox{<<znacznik pocz±tku ramki>>}}_{1B}
  \underbrace{\hbox{<<etykieta typu>>}}_{1B}
  \underbrace{\hbox{<<zale¿ne od typu>>}}_{0-17B}
  \underbrace{\hbox{<<CRC16>>}}_{2B}
\end{displaymath}

\emph{Znacznik pocz±tku ramki} s³u¿y ³atwiejszej identyfikacji ramek
w strumieniu bajtów i jest wspólny dla wszystkich typów (wprowadzamy dla niego
oznaczenie \texttt{BOF} -- \emph{begin of frame}). W protokole wystêpuj±
cztery typy ramek (w nawiasach podane jest jaki rodzaj stacji mo¿e dan± ramkê
wys³aæ, a jaki odebraæ):
\begin{itemize}
  \item BUS (\emph{master} $\rightarrow$ \emph{slave}) -- zapytanie
        o zainteresowanie szyn±
    \begin{displaymath}
      \underbrace{\hbox{<<BOF>>}}_{1B}
      \underbrace{01h}_{1B}
      \underbrace{\hbox{<<adres \emph{slave'a}>>}}_{1B}
      \underbrace{\hbox{<<CRC16>>}}_{2B}
    \end{displaymath}
  \item REQ (\emph{slave} $\rightarrow$ \emph{master}) -- ¿±danie dostêpu do
        szyny
    \begin{displaymath}
      \underbrace{\hbox{<<BOF>>}}_{1B}
      \underbrace{02h}_{1B}
      \underbrace{\hbox{<<CRC16>>}}_{2B}
    \end{displaymath}
    Adres stacji ¿±daj±cej nie jest tu konieczny \emph{master} wie kogo pyta³.
  \item DAT (\emph{slave} $\rightarrow$ \emph{slave}) -- pakiet danych
    \begin{displaymath}
      \underbrace{\hbox{<<BOF>>}}_{1B}
      \underbrace{04h}_{1B}
      \underbrace{\hbox{<<adres odbiorcy>>}}_{1B}
      \underbrace{\hbox{<<adres nadawcy>>}}_{1B}
      \underbrace{\hbox{<<d³ugo¶æ>>}}_{1B}
      \underbrace{\hbox{<<dane>>}}_{1-10B}
      \underbrace{\hbox{<<CRC16>>}}_{2B}
    \end{displaymath}
    Pole \emph{d³ugo¶æ} informuje od d³ugo¶ci pola danych. Adres nadawcy
    $0xFF$ oznacza transmisjê \emph{broadcast'ow±} bez potwierdzenia.
  \item ACK (\emph{slave} $\rightarrow$ \emph{slave}) -- potwierdzenie
        otrzymania danych
    \begin{displaymath}
      \underbrace{\hbox{<<BOF>>}}_{1B}
      \underbrace{08h}_{1B}
      \underbrace{\hbox{<<CRC16>>}}_{2B}
    \end{displaymath}
    Adres nie jest konieczny, nadawca wie do kogo wysy³a³ i nie s± mo¿liwe
    wspó³bie¿ne transmisje, wiêc pakiet zawsze odnosi siê do aktualnie
    trwaj±cej.
\end{itemize}

\section{Architektura rozwi±zania}

\paragraph{Funkcje protoko³u}\

Protokó³ komunikacji bêdzie udostêpnia³ kilka funkcji pozwalaj±cych na jego
u¿ytkowanie z poziomu aplikacji.
\begin{itemize}
  \item \texttt{mss\_run\_master(\textnormal{<<struktura sieci>>})} : funkcja
        wywo³ywana tylko i wy³±cznie w wê¼le \emph{master} i realizuj±ca
        zaprojektowany algorytm przydzia³u ³±cza, \emph{master} zna adresy
        wszystkich stacji w sieci, st±d argument je opisuj±cy;
  \item \texttt{mss\_slave\_send(\textnormal{<<adres>>}, \textnormal{<<dane>>})}
        : wywo³ywana w wê¼le \emph{slave} celem transmisji danych do innej
        (lub innych) stacji, funkcja jest blokuj±ca -- do momentu zakoñczenia
        transmisji, warto¶æ zwracana informuje o powodzeniu operacji;
  \item \texttt{mss\_slave\_recv(\textnormal{<<bufor>>})} : po wywo³aniu tej
        funkcji wêze³ \emph{slave} zaczyna nas³uchiwaæ na szynie transmisji
        adresowanej do niego, odbiera dane do wskazanego bufora odsy³aj±c
        w razie potrzeby potwierdzenie \texttt{ACK} do nadawcy.
\end{itemize}
Funkcja wysy³aj±ca zawiera w sobie ca³± logikê dzia³ania protoko³u --
oczekiwanie na pakiet \texttt{BUS}, odpowied¼ pakietem \texttt{REQ}
i transmisjê. W przypadku b³êdu lub braku potwierdzenia nie próbuje ponownie
wys³aæ danych -- le¿y to w gestii aplikacji.

\paragraph{Aplikacje}\

Przygotowaæ nale¿y dwa programy w jêzyku C: program dla wêz³a \emph{master}
oraz dla wêz³a \emph{slave}:
\begin{itemize}
    \item \texttt{mss-bus-master} to program dzia³aj±cy na wê¼le
          \emph{master}, utrzymuje on statyczn± tablicê adresów hostów
          \emph{slave} i kontroluje dostêp do szyny, kod programu sprowadza
          siê w zasadzie do wywo³ania funkcji \texttt{mss\_run\_master()};
    \item \texttt{mss-bus-slave} to program u¿ytkownika, który bêdzie dzia³a³
          dwóch trybach (zale¿nie od podanych parametrów):
          \begin{itemize}
              \item odbieranie : stacja bêdzie oczekiwa³a na dane adresowane
              do niej, odbiera³a je i wypisywa³a na ekran (u¿ytkowana tu
              bêdzie funkcja \texttt{mss\_slave\_send()}),
              \item wysy³anie : program pobierze dane do wys³ania (z
              \texttt{stdin} lub pliku) i za pomoc± funkcji
              \texttt{mss\_slave\_send()} wy¶le je do wskazanej stacji lub
              w trybie \emph{broadcast}.
          \end{itemize}
\end{itemize}

\section{Projekt testowania}

Testy odbêd± siê w sali 138, bo tam znajduje siê potrzebny sprzêt.
Przetestowane zostan± przede wszystkim sytuacje awaryjne, w szczególno¶ci
od³±czanie wêz³ów w trakcie transmisji/poza transmisj±, wy³±czanie nadawców
i odbiorców, wy³±czanie i w³±czanie urz±dzeñ, zak³ócenia.

Poza tym podczas testów bêdziemy w miarê potrzeb dostosowywaæ parametry
protoko³u m.in. \emph{timeout'y}.

\end{document}

